package operator02;

public class BitOP {

	public static void main(String[] args) {
		
		// 비트연산, 쓸 일은 없으나 정보처리기사에 나옴
		// 비트연산은 비트단위로 계산, 데이터의 최소저장단위가 비트, 0 또는 1만 저장
		
		/*
		 * [쉬프트(shift) 연산자(이항연산자)]             
		 * 
		 * - 두 항이 반드시 정수여야한다, 실수는 에러남
		 * - <는 부호고 <<는 왼쪽으로 간다는 뜻, 비트수만큼 이동
		 * 
		 * 정수 << 정수(오른쪽 정수는 이동할 비트수를 의미): 왼쪽으로 비트수만큼 이동하고 오른쪽에 남는 비트는 0으로 채운다
		 * 
		 * 정수 >> 정수(오른쪽 정수는 이동할 비트수를 의미): 오른쪽으로 비트수만큼 이동하고 왼쪽에 남은 비트는 부호비트로 채운다 (1:음수, 0:양수)
		 * 
		 * 
		 */
		
		byte b1=10, bit1=2;         // = <-이게 할당연산자 오른쪽이 무조건 먼저 실행, 선언과 동시 초기화(즉,지금) 이때만 먼저 메모리 만들고 오른쪽이 들어감
									// = a>b <- 이런식으로 됐을 때가 a>b 이 때가 할당연산자 오른쪽이 무조건 먼저 실행된다는 것
		int result= b1 << bit1;        // byte와 byte의 << 연산이므로 에러 안나게 int에 저장
		
		/*
		 * 10: 00001010  = 8+2 
		 *  
		 * << 왼쪽으로 이동시킨다는 뜻
		 * 
		 * 2하고나면 결과는
		 * 
		 *  :  00101000  -> 8비트에서 앞에 2개가 날아가고 빈자리 2개 오른쪽을 0으로 채운것
		 *  
		 *  4바이트로 치면
		 *  
		 *  0000 0000
		 *  0000 0000
		 *  0000 0000
		 *  0010 1000       -> 계산결과 32+ 8 = 40
		 * 
		 * 
		 */
		
		System.out.printf("%d << %d의 결과: %d%n", b1, bit1, result);
		
		b1 = -9;
		result = b1 >> bit1;   // -9 이진법하면 죄다 1 맨 마지막 4개만 0111
		
		/*
		       128/64/32/16    8/4/2/1
		 * b1   1_ 1_ 1_ 1_   0_ 1_ 1_ 1_ 
		 *    부호비트
		 * 
		 * -> -1*128 이 됨  -> 나머지로 +119를 만들어야함, 부호비트 뒤로 계산해야함
		 * 
		 * 팁
		 * -9에 절대값 씌우면 9, 9보다 크지만 가장 작은 수를 부호비트 처리하면 16이 1 그리고 7을 더하면 -9나오도록 0 1 부여, 그리고 음수면 앞에는 다 1로 처리
		 * 
		 * b1: 1111 0111 에서 >>로 오른쪽 2개 날림
		 * 
		 *     __11 1101
		 *     
		 * 위에 __는 아까 부호비트 1이었으니까 다 1로 채움
		 *   
		 *     1111 1101
		 *     
		 *     -> 계산 팁 128의 1을 부호비트로 보지말고 1끝나는 4의 1을 부호비트로 보고 4*-1 하고 2^0 *1 하면 -4 +1 = 3 최종 결과 
		 * 
		 * 
		 */
		
		System.out.printf("%d >> %d의 결과: %d%n", b1, bit1, result);
		
		// 지금까지 쉬프트연산
		
		b1 = 3;
		byte b2 = -15;
		
		// & 하나짜리 양쪽에 정수가 오면 비트연산자로 쓰임
		
		System.out.println("논리 연산자로 사용된 경우:" +(false & 10>5));       // 하나짜리라 뒤쪽도 계산, false 나옴
	
		
		System.out.println("비트 연산자로 사용된 경우(그 중에서도 AND연산):" +(b1 & b2));      // 양쪽에 t,f가 아닌 정수가 오면 논리연산자 말고 비트연산자로 쓰임
		
		/*
		 * 위 결과 1 은 비트연산 
		 * 
		 * 3=   0000 0011
		 * 
		 * &
		 * 
		 * -15= 1111 0001
		 * 
		 * 15 절대값보다 큰 16을 부호비트로 1 그리고 1만 빼면 됨 16에 1 (그 앞은 쭉1) 첫자리에 1
		 * 
		 * 그리고 비트 단위로 and 연산을 하게 됨, 같은 위아래 쓴 2진수 자리끼리 한다는 뜻 -> 둘 다 1이면 1, 둘 중 하나라도 1이 아니면 0
		 * 
		 * 결과= 0000 0001
		 * 
		 * 
		 */
		
		System.out.println("비트 연산자로 사용된 경우(그 중에서도 OR연산):" +(b1 | b2)); // 둘중 하나가 1이면 무조건 1 
		
		// 결과 = 1111 0011     -> 1끝나는 16자리를 부호비트로 보고 -1*16 그리고 남은 0011의 1로 계산된 3을 더하면 -13 결과
		 
		System.out.println("비트 연산자로 사용된 경우(그 중에서도 XOR연산):" +(b1 ^ b2)); // 비트연산 그냥 ^ 동일, 다르면 1 같으면 0
		
		// 결과 = 1111 0010      -> -14
		
		System.out.println("비트 연산자로 사용된 경우(그 중에서도 NOT연산):" +(~b2));  // 비트연산시 ! 말고 ~ 틸드라고 부르는걸 씀 
		
		// 결과 = 0000 1110      -> 14, 지금 b2를 반대로 부정하므로 -15 = 1111 0001 -> 0000 1110 으로 부정함
		
		
		
		
		
		
		

	}// TODO Auto-generated method stub

}
