package controlstatement03;

public class FORStatement {
		
		/*
		for(int i=0;i<1000;i++) // 반복문으로 데이터만 바꿔주는게 게시판이랑 동일
		System.out.println("Hello World:"+(i+1)); // 천번 찍고싶으면 만번카피 필요 for 반복문으로 천번 바로 가능
		*/
		
		/*
		 for문: 어떤 명령문들을 반복하고자 할때 사용하는 제어문(반복문)
		
		 형식: (아래 틀 암기, 틀이 syntax 문법)
		
		 반복순서:	
		 초기식->반복 조건(조건식)->조건식이 참인경우 for문 안으로(거짓인 경우 for문을 빠져 나감)->증감식->반복조건->참인 경우 for문 안으로->증감식->반복조건->......
		
		// for문도 명령문, 얼마나 반복되든 초기식은 맨 처음 딱 한번만 실행됨
		// 반복조건에는 조건식이 와서, 반복조건이 참일동안 (for: ~동안 의 뜻), for블락 안에 있는 명령문이 실행됨, 그리고 증감식에서 뭔가 증감이 발생, 그리고 다시 반복조건식으로 감
		// 명령문 다 실행 시 증감식으로 이동, 그리고 다시 조건식 시행
		// 증감식을 쓰면 바뀌다가 언젠가 반복조건이 거짓이됨, 그러면 반복조건이 거짓, for 블락 다음이 실행 
		
		 for(초기식 ; 반복조건(조건식) ; 증감식){  //for 블락 시작 (괄호 안에는 세미콜론2개), 
		
		 	반복 조건이 참일때 실행할 명령문들; (하나면 중괄호 {} 생략가능)
			
		 }									//for 블락 끝 (자바는 scope를 블락으로 구분함)
		
		 //////////// for블락 밖
		
		 반복조건이 없거나 조건대신에 true를
		 지정하면 무조건 무한 루프
		 
		 예1]           
		 for(;;){                -> 무한반복, 내부 명령문이 계속 진행
		
		 }
		 예2]
		 for(;true;){           -> 위와 동일, 내부가 true니까
		
		 }	
		
		 -for문은 반복횟수가 정해진 경우 주로 사용한다.
		  반대로 반복횟수를 모를 경우에는 while문을 사용한다.	
		 */
		
	
	public static void main(String[] args) {
		
		/*
		for(int i=0; i<2; i++) {              // i=0 시작 딱 한번만 실행, 0<2이므로 참, i<2보다 작을동안 반복, i++로 1증가 2번 실행
			System.out.println("HW");
		}
		// i=0시작, i<2니까 HW출력, +1 되어 1됨 -> i=1<2 맞으므로 HW출력,  
		// 맨 처음에 i라는 메모리에 0이 저장됨, i<2가 참이니까 HW 출력
		
		for(int i=2; i<0; i--) {              // i=0 시작, i<2보다 작을동안 반복, 애초에 틀려서 출력안됨
			System.out.println("HW");
		}
		
		for(int i=2; i>0; i--) {             
			System.out.println("HW");
		}
		
		 // i=2 시작, i=2>0 반복조건문이 참, for블락 내 명령문으로 들어옴, 명령문 끝나면 증감식, 증감식 이후 반복조건문 갔다가 참이면 다시 명령문, 거짓이면 for블락 밖으로 
		*/
		
		// 반복문을 이용해서 1부터 10까지 누적합: 1+2+3+4+5+6+7+8+9+10
		
		int sum=0; // 누적합을 저장할 변수 선언
		//int i=1 // [x] 같은 메인블락내에서 int랑 바로 밑 for 블락 같은 i 선언은 불가
		for(int i=1 ; i<=10 ; i++) { // i가 1시작, 10보다 작거나 같을동안 반복
			//sum = sum + i; // i값이 계속 변하는중, 이 코드가 10번 반복, 처음에 i 메모리에 1들어가고, sum에는 이미 0 있고, = 오른쪽부터 실시, 0 + 1이 sum에 다시 저장
			sum+=i; // 위에 줄이면 이렇게 쓸 수 있음
			//i=1일때 sum = 0+1
			//i=2일때 sum = 0+1+2
			//반복
		}
		
		System.out.println("1부터 10까지 누적합:"+sum);
		
		// 0+1 이후 i=2 된걸 계산 sum에 2 더함, 3더하고 계속 반복, 0+1+2+~~+10까지 더함
		
		// 1부터 10까지 숫자중 2의 배수의 합: 2+4+6+8+10
		sum = 0;
		// 방법1] 2씩 증가하도록 증감식 작성
		for(int i=2; i<=10; i+=2) { // 또 같은 이름의 i 변수 지정해도 에러x 왜? -> for블락 내에서 각각 사용, for블락 끝나면 메모리에서 i 사라짐, 위 i는 지금 사라진 것
			sum+=i;
		}
		System.out.println("1부터 10까지 2의 배수의 누적합:"+sum);
		
		sum=0;
		for(int i=1; i<=10; i++) { // i가 10 넘어가면 빠져나옴
			if(i % 2 ==0) sum+=i; // i가 2의 배수일때만 일때만 i 누적, 단 위에는 5번 반복, 밑에는 10번 반복, 결과는 당연히 동일, 위에가 더 좋음
		}
		System.out.println("1부터 10까지 2의 배수의 누적합:"+sum);

		// System.out.println("for문이 끝난 후 i의 값:"+i); // i를 변수로 해석할 수 없다고함, 위의 for블락 끝나서 i 사라진 것
		// i는 for블락 안에서만 유효한 변수다
		
		int i=5; // 이 코드는 당연히 위부터 아래로 순차적이니까 1번 실행, 다시 내려갔다 올라올 수 는 없음, 이걸 초기식으로 쓸 수 있는 것
		for( ; i<10 ; i++ ) {} //초기식을 i=5로 안씀, 실행할 명령문 없음, i=6,7,8,9 될때까지는 참, 그리고 명령문할게없음, 그리고 10 되면 for블락 밖으로 빠져나옴
		 // 6,7,8,9,10 으로 5회 반복
		System.out.println("for문이 끝난 후 i의 값:"+i); // [o] i=10나옴
		 
		for(int k=10; k>0 ; k--)  ; { // 왼쪽 세미콜론으로 끝내버리면 {} 블락을 for문과 떨어트린것 이러면 그냥 밑에 블락은 1회 출력
			System.out.println("HELLO WORLD"); // 0되면 빠져나옴, 10번 반복
		}
		
		// 문] 1부터 100까지 숫자중 3의 배수이거나(또는) 5의 배수인 숫자의 합을 구해라(공배수)
		// 단, 3과 5의 공배수인 경우, 누적합에 단 한번만 포함시켜라 (ex. 15, 30, 45, 60, 75, 90 -> 3x5의 배수가 3과 5의 공배수)
		// ex. 3+5+6+9+10+12+15+18+20 ~~~~~~~
		
		sum=0;
		for(i=1; i<101; i++) {
			if(i % 3 ==0 || i % 5 ==0) sum+=i; // 3의 배수만 sum에 누적됨
			// i=1 이면 둘 다 거짓이므로 누적x, 3이면 왼쪽만 참이니까 총 참으로 3누적, 이런식으로 3, 5 누적, 15는 왼쪽, 오른쪽 둘 다 t라 총 t로 15누적
		}
		System.out.println("1부터 100까지 3의 배수이거나 5의 배수의 누적합:"+sum);
		
		// 문] 1부터 100까지 숫자중 3의 배수이거나(또는) 5의 배수인 숫자의 합을 구해라(공배수)
		// 단, 3과 5의 공배수인 경우, 누적합에 제외시켜라 (ex. 15, 30, 45, 60, 75, 90 -> 3x5의 배수가 3과 5의 공배수)
		// ex. 3+5+6+9+10+12  +18+20 ~~~~~~~
		
		// 방법1] ||하고 &&사용
		sum=0; // sum에 들어간거 재설정필요
		for(i=1; i<101; i++) {
			if((i % 3 ==0 || i % 5 ==0 )&& i % 15 !=0) sum+=i;
		}      // 15의 공배수는 이 위에 포함, 이 위에 15의 공배수는 포함하면 안됨, 3과 5의 배수는 누적, 15의 배수는 누적x
		System.out.println("1부터 100까지 3의 배수이거나 5의 배수의 누적합(공배수 제외):"+sum);
		
		// 방법2] ^(XOR)연산 사용
		sum=0;
		for(i=1; i<101; i++) {
			if(i % 3 ==0 ^ i % 5 ==0) sum+=i;           
		}  // 둘 다 같으면 거짓, 15는 둘 다 t t 라서 f 실행안됨, 9는 3의 배수t 5의배수f 하나 다르면 t라 실행됨, 2는 둘 다 f f로 f 실행안됨
		System.out.println("1부터 100까지 3의 배수이거나 5의 배수의 누적합(공배수 제외):"+sum);

		/*
		 * 이중(중첩) for문: for문 안에 for문 (이중for문까지는 아주 많이 씀, 삼중은 잘 안씀)
		 * 이중 for문에서 바깥 for문은 행(row)를 의미
		 * 안쪽 for문은 열(column)을 나타낸다
		 * 
		 * _ _ _ _
		 * _ _ _ _          -> 3행(가로한줄) 4열(세로한줄), 3x4 행렬, 한칸한칸을 cell이라고함, 
		 * _ _ _ _          -> 쉽게 바깥 for문 3번 반복, 안쪽 for문 4번 반복
		 * 
		 * 
		 * 
		 * 
		 * 
		 *  안쪽 for문이 x축 가로 방향으로 한칸한칸을 만듦, 바깥 for문은
		 *
		 * for(;;){
		 *  for(;;){}
		 * }
		 * 
		 * 
		 */
		
		/*
		for(int i=1;i<=2;i++) {
			
			for(int k=1;k<=2;k++) {
				System.out.println("HW");
			}
		}
	 	*/
		
		// 바깥 for문부터 시작, i에 1저장 후 i<=2 참이므로 안쪽 for문 실시, 안쪽 for문 명령문 다 끝나야 바깥 for문의 i++로 갈 수 있음
		// i=1 됐다가, k=1 됐다가, k=2 됐다가, 참이니까 다시 HW출력 후 k=3 됐다가 반복조건거짓이라 안쪽for문 밖으로 나감. 수행할 명령문 없으니 i++로 이동, i=2됨
		// i=2 시작, k=1 다시 시작, k=2 됐다가, 
		// i=1 일 때, k=1 HW 1번째 출력, k=2 HW 2번째 출력
		// i=2 일 때, k=1 HW 1번째 출력, k=2 HW 2번째 출력         -> 이제야 바깥 for문 밖으로 나감
		// 바깥 for문 첫번째에 안쪽 2회, 바깥 for문 두번째에 안쪽 2회, 총 4회 반복
		
		int repeatCount=1;
		for(int k=0; k<3; k++) {
			System.out.printf("[k가 %d일때]%n", k); // k가 3이면 밖으로 나옴
			for(int j=1; j<=3; j++) {
				System.out.printf("[j는 %d,반복횟수:%d%n",j,repeatCount++); // repeatCount 반복횟수를 더해줌
			}
		}
		
		/* 4x4 니까 바깥for, 안쪽for 4번씩 반복필요
		 
		 0 0 0 1 (1,4)   -> 1행의 4열자리
		 0 0 1 0 (2,3)   -> 2행의 3열자리
		 0 1 0 0 (3,2)
		 1 0 0 0 (4,1) 
		 
		 처럼 출력해보자     -> 행번호 + 열번호 = 5일때 1, 아니면 0, k는 행번호, j는 열번호
 		 
		 */
		// 방법1]
		for(int k=1; k<5; k++) { //k 행번호
			
			for(int j=1; j<5; j++) { //j 행번호, 5되면 밖으로 나감
				
				if(k+j ==5) System.out.printf("%-2d",1); // 0 출력 후 줄바꿈하면 안되니까 그냥 printf 씀, println 말고
				else System.out.printf("%-2d",0);
				
			}
		
			System.out.println();  // 안쪽 4번 진행 시 줄바꿈, prinln에 아무것도 안넣으면 됨
		}
		
		// 방법2] 추천, 위에는 5행5열이면 또 숫자 바꿔줘야함, 
		for(int k=1; k<=4; k++) {
			
			for(int j=4; j>=1; j--) {
				if(k==j) System.out.printf("%-2d",1);
				else System.out.printf("%-2d",0);
				
			}
			System.out.println();  // 안쪽 4번 진행 시 줄바꿈, prinln에 아무것도 안넣으면 됨
		}
		
		/*
	
		    *
		    * *
		    * * *
		    * * * *
		  	* * * * * 
		  	
		  	를 출력하여라 -> 규칙이 있어야 프로그램 짤 수 있음
		  	
		 */

		// 방법1] 
		System.out.println("[25번 반복]");
		
		for(int k=1; k<=5; k++) {
			
			for(int j=1; j<=5; j++) {
				if(k>=j) System.out.printf("%-2c",'*');         // k>=j 이런 규칙을 찾는게 중요, k=1일 때 1번 찍고 4번 실행x
				}
			System.out.println();  
		}
		
		// k=2, j=1이면 참이므로 *, j=2이면 참이므로 *, j=3이면 참이므로 내려옴 근데 if 조건문 내에 안맞아서 *안찍음, j=5까지 안찍음, j=6이 되면 줄바꿈으로 내려움 
		
		// 방법2]
		System.out.println("[15번 반복]");
		
		for(int k=1; k<=5; k++) {
					
					for(int j=1; k>=j; j++) {
						System.out.printf("%-2c",'*');        
						}
					System.out.println();  
				}
		
		// k=1이면 j=1 시작, 1>=1반복조건문 맞음, *찍음, j=2됨, 1>=2 거짓이라 아래로 안가고 줄바꿈으로 넘어감, k=2로 바뀜 다시 j=1시작, j=2까지 *찍고, k=3으로 넘어감
		// k=1일때 1번, 2일때 2번, 3일때 3번, 4일때 4번, 5일때 5번 -> 15번 반복해서 구현하는게 퍼포먼스 더 좋음
		
		
		/* 
		 * 문] 아래 형식대로 구구단을 출력
		 * 
		 * (이걸하나의열로) -> 2~9까지 8열, 9행 8열임, 각 열의 첫 2, 3 은 안바뀜, 1~9만 변수, i=1이고 k=2면 i*k=2
		 * 
		 * 2 * 1 = 2   3 * 1 = 3   4 * 1 = 4 ........... 9 * 1 = 9
		 * 2 * 2 = 4   3 * 2 = 6
		 * ..
		 * ..
		 * 2 * 9 = 18
		 *
		 */
		
		
			for(int k=1; k<=9; k++) {  // 바깥이 행 -> x1~x9(1씩증가) -> 9줄, 9행(가로)
					
				for(int j=2; j<=9; j++) {  // 안쪽이 열 -> 2단~9단(1씩증가) -> 8줄, 8렬(세로)
					System.out.printf("%-2d%-2c%-2d%-2c%-5d",j,'*',k,'=',j*k);       
					}
					System.out.println();  
			}
		
			// 선생님
			for(int k=1; k<=9; k++) {
				for(int j=2; j<=9; j++) {
					System.out.printf("%d * %d =%-3d",j,k,j*k);
				}
				System.out.println();
			}

			for(;;) { // 반복조건 없음, 무한반복, 스레드 작업 시 자주 돌림
				System.out.println("무한반복");
				break; // break 쓰면 밑에 프로그램종료 빨간줄 사라짐 -> 무한반복 코드 후 break 후 빠져나와서 바로 종료됨, 이번엔 무한반복 딱 1번 출력
			}          
			
			
			
			System.out.println("프로그램 종료"); // 위가 무한반복이니까 여기 도달 불가, unreachable code 라고 나옴, 
			
			// 반복횟수 모르면 while씀, 정해지면 for -> 그냥 둘 다 for, while 써도 되는데 각자 편한것
		
	}///////main

}////////class
