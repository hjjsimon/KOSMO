package datatype01;

public class CharNBoolean {

	public static void main(String[] args) {
		//char형(기본 자료형):하나의 문자를 저장할 수 있는 자료형(2byte), 0~2^16-1까지 저장됨
		// 값 저장 시 하나의 문자를 싱글쿼테이션, 더블 쿼테이션은 String형(아직 안배운 참조형)

		//char ch1="가"; // 더블 쿼트로 글자 가 감싸면 에러남, 
		// "가"는 String으로 바꾸라고 조언함. 얘는 형변환도 안됨. 참조형은 기본자료형이랑 메모리구조가 달라서 변형불가
		//char ch1=(char)"가"; // 형변환하려해도 안됨
		char ch1 = '가'; //[o] 문자 한개는 됨 '가나' 는 에러남, 숫자로는 44032로 컴퓨터 내에 저장되어있음, 가 라는 문자는 모름
		System.out.println("ch1="+ch1);
		
		char ch2 = 'A';
		int num1 = 2;
		System.out.println(ch2+num1); // A+2는 불가, 근데 컴퓨터는 A를 65 숫자로 정의돼있으므로 계산이 가능, 캐릭터형을 수치형으로 보기도 함
		//char ch3 = ch2 + num1; // 캐릭터+인트형 계산 결과, 큰 인트 돼서 int 4바이트짜리인데, 총 그릇 char 2바이트짜리라 못 넣는것
		
		//방법1] int형에 담는다. char+int=int
		int num2 = ch2 + num1;//[o] 'A' 는 65니까 67
		System.out.println("num2="+num2);
		
		//방법2]연산결과 전체를 char로 형변환, 문자가 나오게 됨
		char ch3 = (char)(ch2 + num1); 
		System.out.println("ch3="+ch3); // 위에는 결과가 인트라 숫자나옴, 밑에는 결과가 char라 문자가 나온 것 
		System.out.println("num2를 char형으로 변환:"+(char)num2);
		
		//아스키코드 혹은 유니코드를 char형으로 형변환하면 해당 코드값에 맞는 문자로 바뀜.
		//문자를 int로 바꿔도 그 문자의 코드가 나옴
		
		System.out.println("%문자를 코드값으로 변환:"+(int)'%'); // %문자를 int로 변환하는것
		System.out.println("%문자를 코드값으로 변환:"+(int)'가'); // 가문자를 int로 변환하는것
		System.out.println("십진수 37(코드값)을 문자로 변환:"+(char)37);

		char ch4 = '1'; // '1' 이건 문자임, 코드값이 49, 0은 48
		char ch4_1=49; //캐릭터명은 65000까지 됨, 지금 ch4에 저장된거랑 ch4_1에 저장된건 똑같은 49라는 코드값, 십진수를 저장
		
		System.out.println("ch4="+ch4+",ch4_1="+ch4_1); //이렇게 하면 같은 문자 1로 저장, char 니까
		
		//규칙2]char형에 값(데이터)저장
		// 1. ''로 감싸서 하나의 문자를 저장
		// 2. 십진수 혹은 16진수로 저장
		// 3. \\(역슬래시, 원)u 16진수형태의 값을 저장할 수 있다.
		// 십진수 저장시 숫자는 아스키코드 혹은 유니코드값이 된다.
		
		char ch5='가';
		char ch5_1=44032; //44032는 16진수로 AC00=A(10)*16^3+C(12)*16^2+0+0=40960+3072
		char ch5_2=0xAC00; //16진수는 0x 붙임, 여기까지 위의 2. 내용
		
		
		char ch5_3='\uAC00'; // 그냥 AC00은 안됨 역슬래시 (굴림체 원표시가 콘솔라스 글꼴이면 역슬래시 원도 됨) 3.내용
							 // 역슬래시 u 추가 시 싱글쿼테이션 안에서 AC00이 유니코드라는 것을 나타내는 것
		
		System.out.println("ch5="+ch5+",ch5_1="+ch5_1+",ch5_2="+ch5_2+",ch5_3="+ch5_3); // 위의 5~5_3 4개는 모두 같은 가 를 지정함
		
		
		// 17을 2진수로 바꾸려면 2로 나누면 2/17 8나오고 나머지 1 , 2/8 4나오고 나머지 0, 2/4 2나오고 나머지 0, 2/2 1나오고 0 더이상 못나눔
		// 17을 2진수로 하려면 1 0 0 0 1 역으로 맨밑 1부터 나머지 0, 0, 0, 1 임, 계산방법
		// 17을 8진수로 바꾸려면 8로 나눔, 8/17 2나오고 나머지 1, -> 계산 시 21
		// 17을 16진수로 바꾸면 -> 11 
		
		// boolean형:true,false 두 값만 가진다
		// 산술연산(+,-,*,/,% 등)이나 비교연산(>,<,>=,<= 등)은 불가, 논리연산은 가능함
		
		// 구글에 ideone 치면 온라인도구 사용가능, 파이썬!!!
		
		boolean b1 = true;
		boolean b2 = false;
		//System.out.println(b1+b2); // 산술연산[x] 연산자는 불린과 불린타입에서 정의가 안된다고 나옴
		//System.out.println(b1>b2); // 비교연산[x] 똑같이 정의 안된다고 나옴
		System.out.println(b1&&b2); // 논리연산[o] 이건 됨
		
		boolean b3 = '가' > 30000; // 가라는 글자가 30000보다 크다? 44032니까 맞음
		System.out.println(b3);
		
		
		
	}//////////main

}///////class
