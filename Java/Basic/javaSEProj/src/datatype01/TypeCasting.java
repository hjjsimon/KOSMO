package datatype01;

public class TypeCasting {

	public static void main(String[] args) {
		
		// 데이터가 저장되는 메모리 = 즉, 변수 의 타입을 다른 타입으로 바꾸는 것이 "형변환",
		// 괄호를 쓰고, ex. (괄호 안에 바꾸려하는타입을 쓰면 됨) -> 괄호 안에 있는걸 캐스팅연산자 라고 함
		// 참조형 간의 형변환은 나중에 배움. 기본자료형만 배움.
		// 자동형변환, 강제적형변환 2개 있음
		// 자동 형변환. s->i 하려면 (괄호안에썼던i') 임시메모리 i'에 잠깐 넣었다가 i에 넣어줌. 데이터 손실 없음 ㄱㅊ
		// 강제적 형변환. L->I 하려면 큰 그릇 -> 작은 그릇이라 데이터 넘칠 수 있음, 작은 임시 메모리에 대충 넣었다가 I에 넣음, - 마이너스 값이 저장됨. 데이터 날아갔으니까. 손실 걍 내 책임
		
		/*
		 * 1]자동 형변환:
		 * 작은 그릇의 데이터를 -> 큰 그릇에 넣을 때
		 * 형변환이 자동으로 일어남
		 * 즉 형변환 불필요
		 */
		
		byte b1=65;
		short s1;
		s1=b1;  // [o]자동형변환 b1 1바이트, s1은 2바이트 2배라 꽉차도 절반, 넘겨도 문제 없음
		System.out.printf("b1은 %d, s1은 %d%n", b1, s1);
		//바이트 쇼트 정수형이니까 %d, 모르면 %s하면 됨 
		
		int num1=b1+s1;
		//작은것끼리 더하면 4바이트 int, int를 int로 대입하니까 문제 없음 형변환 아님
		/*
		 *  
 		 *    128/64/32/16/8/4/2/1
		 *  b1 0_ 1_ 0_ 0_ 0_ 0_ 0_ 1_  -> 1바이트에서 이러면 65 양수니까 부호비트 0
		 *  
		 *  
		 *  
		 *    2^15/ / / / / / /
		 *  s1 0_ 0_ 0_ 0_ 0_ 0_ 0_ 0_   -> 2바이트짜리 쇼트 65
		 *   
		 *   
		 *    128/64/32/16/8/4/2/1 
		 *     0_ 1_ 0_ 0_ 0_ 0_ 0_ 1_
		 * 
		 * 
		 * 
		 *        2^31
		 *   b1+s1 0_ 0_ 0_ 0_ 0_ 0_ 0_ 0_   -> 65 2개 더해서 130 나와야함
		 *         
		 *        
		 *         0_ 0_ 0_ 0_ 0_ 0_ 0_ 0_
		 *       
		 *        32768(=2^15)
		 *         0_ 0_ 0_ 0_ 0_ 0_ 0_ 0_
		 *   
		 *        128                2
		 *         1_ 0_ 0_ 0_ 0_ 0_ 1_ 0_
		 *   
		 *   
		 *   
		 *   
		 *   num1  0_ 0_ 0_ 0_ 0_ 0_ 0_ 0_   -> 위의 결과 값을 4바이트 새로 만든 num1 메모리에 그대로 저장
		 *   							 		4바이트 -> 4바이트 이므로 형변환x
		 *         0_ 0_ 0_ 0_ 0_ 0_ 0_ 0_
		 *         
		 *         0_ 0_ 0_ 0_ 0_ 0_ 0_ 0_
		 *         
		 *         1_ 0_ 0_ 0_ 0_ 0_ 1_ 0_
		 *   
		 */
		
		char ch1=65; //'A'의 코드값 저장(상수 65를 코드값으로 처리함), 65는 int형 상수, -65도 에러 음수니까
		//char ch2=b1  // b1도 65니까 같은데 왜 빨간줄?, b1=65 이건 하드코딩 음수가 들어갈 수도 있음. 코드값 char에는 음수가 없으므로 b1 아직 변수라 미정 음수가능. char로 불가, 코드값은 음수가 없다.
				     // 65 확실하면 형변환 가능
		//char ch2=b1; // 그릇이 ch 2바이트로 b 1바이트보다 커도 음수되니까 불가. 위랑 동일한 설명
		//char는 부호가 없고 byte는 부호가 있는 자료형이다. 즉 그릇의 구조가 다르다. 예 이솝우화. 
		//[x] 자동형변환의 예외가 위 예시(작은그릇-> 큰 그릇). 형변환을 해야한다. 계속 같은 말.
		
		char ch2=(char)b1;
		System.out.printf("ch2=%c%n",ch2);
		/* 
		 * 2]강제적 형변환:
		 * 큰 그릇의 데이터 -> 작은 그릇에 담을 때
		 * 캐스팅 연산자를 사용:(자료형)
		 * 데이터 손실이 일어날 수 있음
		 * 강제 형변환해도 충분히 담아지면 데이터 손실 없음
		 */
		
		short s2=100;
		//byte b2=s2; //[x]
		byte b2=(byte)s2;
		System.out.printf("[데이터 미손실] b2는 %d%n", b2);
		
		
		/*
		 * 100 되려면
		 * 
		 * s2 0_0_0_0_0_0_0_0_            -> 임시 메모리에 변환한 바이트로 임시 메모리 하나 만듦 
		 *    0_1_1_0_0_1_0_0_                            -> 밑에부터 복사한 후 b2로 넘김, 데이터 손실은 없음
		 * 
		 *
		 */
		
		/*
		 * 데이터 손실이 일어나는 경우]
		 */
		
		int num3=300;
		//b2=num3; //[x]
		b2=(byte)num3;
		
		System.out.printf("[데이터 손실] b2는 %d%n", b2); // 300이었는데 b2=44 나옴. 데이터 손실남
		
		// 4바이트 300이면 256, 32, 8, 4
		/*
		 * 아래가 num3
		 * 
		 * 0000 0000
		 * 0000 0000
		 * 0000 0001             -> 256  얘가 날아가서 44만 남은 것
		 * 0010 1100             -> 32+8+4 =44
		 * 
		 */
		
		double d1=3.14;
		// int num4=num3+d1; // [x] 결과 double라서 int 불가
		
		//방법1] int 안되니까 그냥 double형에 담는다(형변환 없이)
		
		double d2=num3+d1;
		
		//방법2] 연산결과 전체를 int로 형변환
		
		int num4=(int)(num3+d1);
		
		//방법3] double만 int로 바꿈, int 더하기 int = int
		
		num4=num3+(int)d1;
		
		// 변수, 상수, 자료형, escape 완료
		// 앞으로 연산자  -> 기호도 있고, 문자도 있고
		// 끝나면 제어문
		// 끝나면 메소드(=함수)
		
		// 변수, 자료형 2개 끝남 총 5개 중
		
	}/////////main

}//////////class
