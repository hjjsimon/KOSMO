package io24.node;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;

//IO, 파일에 데이터를 저장, 파일에 저장된 데이터를 자바가 읽어와서 프로그램에서 출력해줌->자바IO교안 참고
	//받은 데이터는 컬렉션에 저장, 컬렉션도 변수(메모리), PC끄면 1000명 저장한거 날아감, 프로그램 실행하는 동안에만 메모리에 올라감, 변수에 데이터가 저장되어있으니까
	//저장된 데이터를 파일로 저장하자!입력받은 데이터를 프로그램 밖, 즉 파일로 내보내는걸 출력(Output)이라함, 변수에는 데이터가 저장x
	//학생.txt 저장된 학생정보를 변수로 읽어오면 프로그램 내부로 불러들이는 입력(Input), 합쳐서 IO라고함 ->사실 패턴임
	//프로그램, 파일을 연결해야함 이걸 Stream이라고함, Stream이 Input스트림(파일의 데이터를 .java로 가져옴, 바이트 단위로 읽는 read()메소드를 씀), Output스트림으로 엄격하게 나눠짐
	//관을 통해서 데이터가 흘러간다~ Stream
	//.java프로그램에서 데이터를 가공하여 출력하면 모니터(콘솔)창으로 또는 파일로(.txt) 내보낼 수 있음 -> Output스트림이라고하고 2개임(콘솔로 연결/파일로연결) 
	//데이터의 근원, 소스가되는 파일(학생.txt)를 데이터소스라고함, 데이터가 최종 도달하는 곳은 데이터목적지라고함(콘솔 또는 파일은 맞음)
	//읽을때는 read(), 쓸때는 write -> 지금까지는 쓸때 print, println으로 썼는데 write도 됨
	//데이터 읽어오면 인풋스트림, 데이터 출력하면 아웃풋스트림
	//인풋스트림과 소스, 인풋스트림과 프로그램, 아웃풋스트림과 프고르매, 아웃풋스트림과 데이터목적지 -> 4개 노드 존재, 노드로 구성된 인풋,아웃풋스트림을 노드스트림이라고함
	//노드스트림 사이에 뭔가를 끼울 수 있음 이걸 필터스트림이라고함-> 말그대로 필터링하는 역할, 인풋스트림, 아웃풋스트림 둘 다 중간에 필터스트림 존재가능, 노드스트림 사이에만 필터스트림이 들어갈 수 있음
	//자바IO는 패턴을 갖는다****** 3개 
	//1. 스트림생성(데이터 읽을때 인풋, 출력시 아웃풋) ex. 데이터소스와 프로그램 사이에 빨대를 꽂았다=인풋스트림, 모니터나 파일과 프로그램 사이에 빨대를 꽂았다=아웃풋스트림 
	//2. read()->인풋, 읽을때 씀/ write()->아웃풋, 출력에 씀
	//3. close -> 인풋, 아웃풋스트림을 다 쓰면 거둬들임
	//다른 언어는 스트림 하나로 입력, 출력 다 씀, 자바는 나뉜게 특이
	/*
	 4] 스트림의 특징

		-FIFO(Fisrt In First Out)구조 ->ABC 엔터치면, \n\rCBA로 스트림 들어감, 처음 들어간 A부터 나옴
		-단방향(읽는 스트림/쓰는 스트림 엄격히 구분) 즉 입출력을 동시에 지원하진 않는다
		-스트림에 들어간 데이터가 처리되기 전에는 스트림을 사용하는 스레드는 블럭킹에 빠진다.
		 (예: 키보드 입력시 입력할때까지 블락킹 됨) -> 데이터 입력전에는 블락킹됨, nextint같은거

	[주요 스트림 분류표] -> 빨대 자체가 1바이트씩 가는게 바이트스트림, 영어나 숫자는 1바이트, 한글은 2바이트, 문자단위로 흘러가는걸 문자스트림이라고함 

========================================================================================================================================
		 구 분     |                 바이트 스트림(1byte)               |                문자 스트림(1 또는 2byte)
===========================+========================+===========================+==========================+===========================
			   	  |                        |                           |                          |
	추상 클래스      |   InputStream          |   OutputStream            |       Reader             |      Writer
                  |                        |                           |                          |
-------------------------- +------------------------+---------------------------+--------------------------+---------------------------- 
			      |(데이터소스=파일에서 읽어옴)  |(데이터 목적지=파일로 내보냄)    |       (문자단위로 이동)     |
Node Stream       |   FileInputStream      |    FileOutputStream       |       FileReader         |      FileWriter 
소스,목적지에 직접연결 |                        |                           |                          |
---------------------------+------------------------+---------------------------+--------------------------+----------------------------
			                                |		                   |
Bridge Stream						    	|	InputStreamReader      |      OutputStreamWriter
									     	|                          |
---------------------------+------------------------+---------------------------+--------------------------+-----------------------------
	              |                        |                           |                          |
Filter Stream     |   DataInputStream      |     DataOutputStream      |       BufferedReader     |       BufferedWriter
(필터마다 용도다름)   |                        |                           |                          |
	              |   BufferedInputStream  |     BufferedOutputStream  |                          |       PrintWriter(프린트니까 읽는read는없음)
                  |                        |                           |                          |
			      |   ObjectInputStream    |     ObjectOutputstream    |                          |
===========================+========================+===========================+==========================+=============================

->키보드는 바이트단위밖에 못읽음, 모니터는 바이트단위밖에 출력못함 -> 키보드, 모니터를 표준 입출력장치라고함, 둘 다 바이트기반임
->입력장치: 디지타이저(CAD펜으로), 마우스, 키보드 등 
->출력장치: 프린터, 플로터(?), 모니터 등
->키보드, .java사이에는 인풋스트림(1바이트짜리), 모니터, .java사이에는 아웃풋스트림(1바이트짜리)만 가능

	 */
/*
[표준 입출력 장치:]
표준 입력장치:키보드
표준 출력장치:모니터

키보드(데이타소스)로부터 데이타를 읽어서 모니터(데이타 목적지)에 출력하자

노드 스트림: 데이타 소스나 목적지에 직접 연결 할 수 있는 스트림.
            
키보드에 직접 연결할 수 있는 바이트 기반의 노드 스트림(입력 스트림):System.in*****(암기)->시스템클래스의 멤버가 in, InputStream 타입

모니터에 직접 연결할 수 있는 바이트 기반의 노드스트림(출력 스트림):System.out*****(암기)->시스템클래스의 멤버가 out, OutputStream타입
*/

public class STDNodeInOut {

	public static void main(String[] args) throws IOException {

		//1]바이트 기반의 입력용 노드스트림 생성(키보드와 직접 연결가능한 노드스트림)
		InputStream is=System.in; //이것도 변수에 담음, InputStream, 자바.IO패키지, 입력스트림 생성한것(리드 있음)
		//2]바이트 기반의 출력용 노드스트림 생성(모니터와 직접 연결가능한 노드스트림)
		PrintStream out=System.out;//프린트스트림 클래스는 아웃풋스트림을 상속받음 -> 부모인 아웃풋스트림에 저장해도 됨, 출력스트림 생성함 (라이트나 프린트 있음)
		//3]is(입력스트림)으로 읽고 out(출력스트림)으로 출력
		//3-1]is로 키보드부터 입력받기
		//int read(): 입력스트림으로부터 1바이트씩 읽어서 그 값을 아스키코드값으로 반환(1바이트만 읽어서 AB엔터치면 앞의 A만 읽고, A만 출력, 모니터에 65나옴, \n\rB 스트림에 남아서 다음 입력문제됨)
		//int ascii=is.read();//스트림 끝에 도달하면 -1반환, 키보드에서 데이터 가져오니까 예외반환, 그냥 에러 던져, int반환하므로 int로 받아-> 원래 int ascii=System.in.read();와 동일, 그냥 담아서 대체한것뿐
		//3-2]out로 모니터에 출력 
		//4-1]print()계열 메소드로 출력:아스키코드값을 출력->print계열은 flush할 필요없음 -> 아웃풋스트림에 있는걸 flush함-> 응가가 A -> 버튼(flush)눌러야 A가 모니터로 감 
		//out.println("입력한 문자:"+ascii); //이전에는 변수에 안담고 System.out.println();씀
		//4-2]write()계열 메소드로 출력: 입력한 문자 그대로 출력(write는 줄바꿈없음)
		//write계열 메소드는 자동 flush가 안된다. 즉 출력스트림에 있는 값을 데이터목적지로 보내려면 flush()하거나 close()해야한다
		//out.write(ascii); //이것만 쓰면 모니터로 안보임, flushing이 안된것, flushing 해줘야함
		//out.flush();//근데 아스키코드 아니고 입력한 문자 a가 그대로 출력됨
		//out.close();//스트림 닫기, write로 스트림에 A가 들어감, close는 스트림을 뺀다는것, 그러면 스트림에 있던게 자동 flushing됨-> 관을 빼서 다 모니터로 나온다는뜻
		//out.println("프로그램 끝");//출력스트림 닫으면 이후 출력불가, 관을 빼버려서 "프로그램 끝"이 들어갈 스트림이 없음, 출력 불가능함
		//모든 입출력스트림은 사용후 스트림을 닫아야한다(단, 키보드 또는 모니터와 연결된 표준입출력스트림은 닫지않아도 무방)
		//ABC라고 입력 후 엔터치자
		//out.println(ascii);//A출력
		//out.println((char)is.read());//B출력, 숫자를 캐릭터로 변환
		//out.println((char)is.read());//C출력
		//out.println(is.read());//\r출력(콘솔에 안보임) -> char빼야 13
		//out.println(is.read());//\n출력(콘솔에 안보임) -> char빼야 10
		//사용자가 입력한 문자 그대로 출력하기 즉, ABC를 그대로 모니터(콘솔)에 출력]
		//ctrl+z(이클립스용 콘솔)을 입력할 때 read()는 -1 반환
		int ascii;
		//while((ascii=is.read()) != -1) {//괄호값이 -1이면 빠져나갈것, 키보드로 읽은게 -1이 아니면 true로 들어감, A는 65라 들어감 -> 반복하며 read호출함, read로 A, B, C, \r, \n 하나씩 읽는것, 다 읽어와서 비워짐, read()가 또 스트림에서 읽으려고하는데 없음
			//방법1]write계열 사용
			//out.write(ascii);//write는 줄바꿈 없음 //컨트롤 z 누르면 계속 입력되는거 끝남
			//out.flush();
			//방법2]print계열 사용(한글은 깨짐)
			//out.println((char)ascii);//int니까 코드값출력, 형변환
		//}
		//사용자가 입력한 문자열을 변수에 그대로 저장, 즉 read()메소드로 Scanner클래스의 nextLine()메소드 기능 구현하기(Scanner나오기 전까지 이렇게함)
/*		out.println("문자열을 입력하세요?");
		StringBuilder buf=new StringBuilder();//이게 뭐 빠르대
		while((ascii=is.read()) !=13) {//\r이 13이니까 13읽으면 바로 빠져나오게함
			buf.append((char)ascii);
		}
		out.print("입력한 문자열:"+buf);*/
		int totalByte=0, repeatCount=0;//진짜 read()가 byte단위로 읽는지 테스트
		StringBuilder buf=new StringBuilder();
		//ABCDE하고 한칸 띄고 12345 엔터 -> ABCDE 12345\r\n 될것 13포함 12번 read 호출해야함
		//필터효과 적용전] 총바이트수:11, 반복회수:11, 입력문자열:ABCDE 12345
/*		while((ascii=is.read()) !=13) {//\r 읽으면 while 빠져나옴
			totalByte++;//읽을때마다 ++함
			repeatCount++;
			buf.append((char)ascii);
		}*/
		//out.println(String.format("총 바이트 수:%s,반복횟수:%s,입력문자열:%s",totalByte,repeatCount,buf));//반복횟수랑 총바이트수 같음

		//아래 선생님이 짠 코드는 이해 못해도 됨, 여튼 지금 하는거 엄청 중요함
		/*
		 abstract int-> read()-> Reads the next byte of data from the input stream. ->A를 65로 반환
		 int->read(byte[] b)->Reads some number of bytes from the input stream and stores them into the buffer array b.-> ABCDE 12345를 총 바이트 11로 인트 반환, 문자열은 차곡차곡 byte[]배열에 저장됨, b[0]에 65, [1]에 66... 이렇게 1바이트씩 스트림에서 읽어서 저장함 -> 1은 다시 [0]번방에 저장 49로, 6바이트 읽을때마다 6씩 추가해 반환하는것
		 스트림에 1바이트씩 올라감, read()로 1바이트씩 다 빌때까지 읽음
		 read(byte[])로 배열 6개씩 담는다고치면, 그대로 통으로 반환해줌		  
		 */
		//필터효과 적용]계란판에 담고 내보냄
		//read(byte[]):1바이트씩 읽어서 읽은 문자를 바이트형 배열에 채운다. 입력스트림에 있는 모든 문자를 읽은경우 혹은 바이트형 배열이 다 채워진 경우 "읽은 바이트 수 반환"
		//A\r\n입력시 방 0번부터 65, 13, 10 저장, 읽은 바이트수 3 반환
		byte[] b=new byte[10];//10개짜리 배열 만듦
		boolean isEnter=false;//컨트롤z만 누르고 바로 엔터시 빠져나오려고함
		while((ascii=is.read(b)) != -1){//b가 가리키는 배열에 하나씩 입력한걸 넣음 [65]~~ 0번부터 이런식
			totalByte+=ascii;//배열 6개로 읽은 바이트수 6개면 ascii에 6저장됨, 다 채웠으면 실행끝난것, 바이트형 배열 채울때까지 계속 1바이트씩 읽음, 다 채우면 읽은 바이트수 반환, 실행끝, 근데 다 채우지 않아도 스트림에 3글자밖에 없으면 배열 빈칸 남음, 3반환 !=-1 맞으므로 while로 들어와서 ascii더해줌 
			repeatCount++;
			//읽은 바이트수(ascii)만큼 반복하면서-> 반환 ->ascii=is.read(b) ->반환을 해야 메소드가 끝남, ascii로 값을 반환하기까지 read()메소드가 계속 진행된다! 이게 중요!***
			for(int i=0;i<ascii;i++) {//ABCDE 12345면 10칸 배열에 ABCDE 1234만 저장, 읽은 바이트수 ascii에는 10이 들어감
				if(b[i]!=13&&b[i]!=10) buf.append((char)b[i]);//\r\n이 아니면 누적
				else if(b[i]==13) {//컨트롤 z만 누르고 엔터시 바로 빠져나올때
					isEnter=true;
					break;//for문 나옴
				}
			}
			if(isEnter) break;//while문 나옴
		}
		//스트림에 \n\r5남음, 5는 0번방부터 다시 덮어씀, 3바이트 읽은건 ascii로 3반환, 3을 totalByte에 누적하면 13이됨, repeatCount=2됨, ascii=3,
		//\r이면 바로 나오면됨, 굳이 10말고 13해도됨 ->else if(b[i]==10) { -> ==13, 총 바이트수는 13, 반복횟수 2번 -> 반복횟수가 적어서 지금 방법이 더 효율 좋음
		
		out.println(String.format("총 바이트 수:%s,반복횟수:%s,입력문자열:%s",totalByte-2,repeatCount,buf)); //이번엔 \r\n까지 읽어서 바이트수에서 2 빼줘야함
		
		
		
		
		
		
		
		
		
		
		
	}

}
