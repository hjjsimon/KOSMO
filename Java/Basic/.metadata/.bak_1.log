!SESSION 2023-03-09 09:31:19.176 -----------------------------------------------
eclipse.buildId=4.26.0.20221201-1200
java.version=17
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file D:\HJJ\Workspace\Java\Basic\.metadata\.bak_0.log
Created Time: 2023-03-09 14:07:08.535

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:08.536
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math");,총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:08.538
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:08.538
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:09.318
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math");(,총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:07:09.319
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:07:09.319
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:09.508
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math");(,총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:09.510
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:09.510
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:10.918
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math");(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:07:10.919
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:07:10.919
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:11.015
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math");(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:11.016
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:11.016
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:12.603
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:07:12.603
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:07:12.604
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:12.698
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:12.699
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:12.700
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:14.341
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:14.342
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:14.342
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:15.180
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:15.180
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:15.180
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:15.183
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:07:15.183
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:16.622
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:16.623
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:16.623
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:16.625
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:07:16.626
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:17.890
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:07:17.890
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:07:17.890
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:18.227
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:18.227
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:18.227
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:18.233
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:18.234
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:18.234
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:20.389
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:20.390
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:20.390
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:20.392
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:07:20.393
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:22.364
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:22.364
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:22.365
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:22.367
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:07:22.367
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:28.047
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:28.048
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:28.048
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:28.051
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:07:28.051
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:28.804
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:28.804
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:28.805
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:33.888
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:33.889
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:33.889
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:35.033
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:07:35.034
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:07:35.034
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:07:35.037
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:07:35.037
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:28.487
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:08:28.488
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:08:28.488
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:28.490
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:08:28.491
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:30.790
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:08:30.790
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:08:30.790
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:31.653
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);
		
		("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:08:31.653
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:08:31.654
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:31.757
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);
		
		("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:08:31.757
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:08:31.757
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:35.900
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:08:35.900
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:08:35.900
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:35.962
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:08:35.963
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:08:35.963
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:37.114
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor); ("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:08:37.115
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:08:37.115
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:37.249
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor); ("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:08:37.250
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:08:37.251
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:38.755
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:08:38.755
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:08:38.755
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:38.835
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:08:38.836
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:08:38.837
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:45.962
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:08:45.963
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:08:45.963
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:45.966
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:08:45.966
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:50.196
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:08:50.197
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:08:50.197
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:08:50.199
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:08:50.200
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:02.157
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:02.158
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:02.158
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:14.444
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:14.444
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:14.444
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:22.093
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:22.093
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:22.094
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:27.443
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:27.444
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:27.444
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:27.447
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:09:27.447
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:28.231
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:28.231
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:28.231
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:28.234
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:09:28.234
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:31.107
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);(영어:+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:09:31.107
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:09:31.107
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:31.215
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);(영어:+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:31.216
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:31.216
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:37.128
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:09:37.129
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:09:37.129
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:37.342
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:37.343
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:37.344
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:40.864
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:40.865
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:40.865
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:43.993
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:43.993
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:43.994
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:49.175
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:49.175
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:49.175
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:50.390
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("영어:"+eng);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:50.391
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:50.391
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:50.905
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:09:50.906
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:09:50.906
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:51.006
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:51.008
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:51.008
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:51.901
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:51.902
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:51.902
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:52.493
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:52.493
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:52.493
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:52.496
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-09 14:09:52.496
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:56.163
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:09:56.163
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:09:56.163
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:56.236
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:56.237
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:56.238
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:57.326
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		("영어:"+eng);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:09:57.326
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:09:57.326
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:57.330
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		("영어:"+eng);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:57.331
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:57.331
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:57.922
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		("영어:"+eng);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:57.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:57.923
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:58.535
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		("영어:"+eng);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:58.535
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:58.535
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:59.091
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		("영어:"+eng);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:59.091
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:59.092
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:09:59.896
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);("총점:"+total);
		
		("영어:"+eng);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:09:59.896
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:09:59.896
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:00.407
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:10:00.407
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:10:00.407
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:01.086
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:10:01.087
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:10:01.087
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:01.530
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:10:01.530
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:10:01.531
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:02.428
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:10:02.428
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:10:02.428
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:05.828
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:10:05.828
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:10:05.828
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:06.311
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",영어:"+eng);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:10:06.312
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:10:06.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:486)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:407)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:366)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:287)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:485)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1286)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1075)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1117)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1113)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1594)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4865)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4743)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5022)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3640)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:06.826
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:10:06.826
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:10:06.826
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:07.195
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",수학:"+math);(",총점:"+total);
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-09 14:10:07.195
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-09 14:10:07.195
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:07.747
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",수학:"+math);(",총점:"+total);
		
		
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:10:07.747
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:10:07.747
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:08.570
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",수학:"+math);(",총점:"+total);
		
		(",영어:"+eng);
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-09 14:10:08.571
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-09 14:10:08.571
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-09 14:10:08.651
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package datatype01;

public class JungSuType {

	public static void main(String[] args) {
		/*
		 원칙] 1. 큰 자료형(그릇)과 작은 자료형(그릇)의 연산결과는 큰 자료형을 따른다. ex. int(4) short(2) 더하면 인트나옴 
		 	  2. 같은 자료형끼리의 연산 결과는 같은 자료형이 된다. ex. 인트 + 인트 = 인트
		 	  예외] int(4byte)형보다 작은 자료형(byte(1),short(2),char(2))들끼리 연산 결과는 int(4)형이다. ex. 바이트 더하기 쇼트는 인트
		 */
		//규칙1] 기본형에서 수치형(정수형,실수형) 중 정수형에서 대표 자료형은 int임.
		byte b1; //b1이라는 이름의 메모리를 만든 변수 선언, 크기는 1바이트, byte를 int로 바꾸면 밑밑 128도 됨
		b1 = 127; //[o] 최대 127까지 저장 가능
		System.out.println("b1="+b1);
		//b1 = 128; //[x] 127 넘어서 안됨. 마우스 갖다대면 타입 미스매치, 타입이 안맞는대 바이트인데 128은 인트형상수임, 127도 int에 들어가는 int형 상수는 맞음
		b1 = (byte) 128; //형변환이 일어남, 128빨간줄의 첫번째 클릭한 결과, 바이트로 넣음
		System.out.println("b1="+b1);
		//규칙2]int형보다 작은 자료형(byte,short,char)들의
		//연산결과는 int형이다. (예외)
		byte b2=20,b3=30;
		//byte b4=b2+b3;//20+30은 50인데 왜 int에 담기지? 연산결과가 왜 4바이트야?, 아 b2,b3는 변수라 뭐가 담길지 몰라서 아예 int로 담아버리는 것 20말고 127됨
		//[x]20,30은 사용자가 입력하는 값, b2+b3는 넉넉하게 int로 넣어줌
		//방법1]연산결과인 int형에 담는다
		int num1=b2+b3; //b2 b3 둘다 바이트라 합쳐도 int 못넘으니까 ㄱㅊ
		System.out.println("num1="+num1);
		
		byte b4=(byte)(b2+b3);//방법2]위에처럼 b2 b3를 바이트로 찌그러트려서 담아버림
		System.out.println("b4="+b4);
		
		short s1=1000,s2=2000;
		//short s3 = s1+s2; //똑같이 타입미스매치나옴
		num1 = s1+s2;//[o] 방법1] num1 인트니까 괜찮음, num1 변수를 바꾼것(불확실)
		System.out.println("num1="+num1);
		//방법2] short에 담기 6만5천얼마까지 가능, 위 결과 동일
		short s3 = (short)(s1+s2);
		System.out.println("s3="+s3);
		/*
		 규칙3]정수형에서 int형보다 작은 자료형들을 제외한 자료형들끼리(int,long)의 연산결과는 모두 원칙
		 ex. int+int=int/ int+long=long/ long+long=long 
		 */
		int num2=100,num3=200;
		long ln1=1000,ln2=2000;
		num1 = num2+num3;//연산결과 int형 값 바뀜 num1 300으로
		System.out.println("num1="+num1);
		long ln3 = ln1+ln2;//연산결과 long형
		System.out.println("ln3="+ln3);
		//int num4 = ln1+num2; //[x]빨간줄, int+long이므로 long 가야함
		ln3 = ln1+num2;//해결1]long형에 담는다
		System.out.println("ln3="+ln3);//1100으로 바뀜
		//해결2]연산결과 전체를 int형으로 찌글 변화
		int num4 =(int)(ln1+num2);//[o]
		//해결3]굳이8바이트 아까움 4바이트 인트에 넣는 다른 방법, long만 인트로 찌글
		num4 =(int)ln1+num2;//[o]
		
		//long ln4 = 2;//2는 4바이트에 담음, 정수형은 무조건 4바이트 인트 21억까지가능
		
		//long ln4 = 2200000000; //[x]22억 충분한데 왜 안되지 8바이트 2^63인데? 22억은 인트형 상수, 그냥 정수니까 롱형급 큰데 인트라고 생각하는 것, 
		long ln4 = 2200000000L; // L; 가 롱형 상수라는 뜻 (l, L 소,대문자 둘 다 가능)
		System.out.println("ln4="+ln4);
		//규칙4] 숫자앞에 0(영)이 붙으면 8진수 의미
		num4 = 0412; //8진수 412는 266 십진수라는 뜻 -> 8^2*4 + 8^1*1 +  
		System.out.println("num4="+num4);
		//규칙5] 숫자 앞에 0x(0X)가 붙으면 16진수
		//0 1,2...9,A(10의미),B(11)~~F(15)
		num4 = 0x10A;//1*16^2 + 0*16^1 + A(10)*16^0 = 256+0+10
		System.out.println("num4="+num4);
		//1]국어,영어,수학 점수 및 점수 총합을 저장할 수 있는 변수 4개를 선언하여라(int사용)
		
		int a;
		int b;
		int c;
		int all;
		
		int kor,eng,math,total;
		
		//2]국어에는 89, 영어에는 99, 수학은 78을 저장하여라
		
		a = 89;
		b = 99;
		c = 78;
		
		kor=89;
		eng=99;
		math=78;
		
		//3] 국영수의 총합을 구해서 1]번에서 선언한 총합 저장용 변수에 저장하여라
		
		all = a+b+c;
		
		total=kor+eng+math;
		
		//4] 각 국영수 점수 및 총합을 출력하여라, 더블쿼테이션안에 있는건 그대로 출력됨, 콤마 넣어주면 구분되는 센스
		
		System.out.println("a="+a);
		System.out.println("b="+b);
		System.out.println("c="+c);
		System.out.println("all="+all);
		
		System.out.println("국어:"+kor);
		System.out.println("영어:"+eng);
		System.out.println("수학:"+math);
		System.out.println("총점:"+total);
		
		System.out.println("국어:"+kor);("수학:"+math);
		
		("영어:"+eng);("총점:"+total);
		
		System.out.println("국어:"+kor);(",수학:"+math);(",총점:"+total);
		
		(",영어:"+eng);
		
	}///////////main

}////////////////////class

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
